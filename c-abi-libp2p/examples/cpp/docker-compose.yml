services:
  nat1:
    image: alpine:3.23
    container_name: nat1
    cap_add:
      - NET_ADMIN
      - NET_RAW
    sysctls:
      net.ipv4.ip_forward: "1"
    environment:
      INTERNAL_IP: 172.20.0.2   # netA side
      EXTERNAL_IP: 10.0.0.2   # netB side
    networks:
      netA:
        ipv4_address: 172.20.0.2
      netB:
        ipv4_address: 10.0.0.2
    command:
      - sh
      - -euxc
      - |
        apk add --no-cache iptables iproute2

        : "$${INTERNAL_IP:?INTERNAL_IP is required}"
        : "$${EXTERNAL_IP:?EXTERNAL_IP is required}"

        internal_if="$(ip -o -4 addr show | awk -v ip="$${INTERNAL_IP}" '$4 ~ ip"/" {print $2; exit}')"
        external_if="$(ip -o -4 addr show | awk -v ip="$${EXTERNAL_IP}" '$4 ~ ip"/" {print $2; exit}')"

        if [ -z "$$internal_if" ] || [ -z "$$external_if" ]; then
          echo "Failed to detect NAT interfaces (internal_if=$$internal_if external_if=$$external_if)" >&2
          echo "ip -o -4 addr show output:" >&2
          ip -o -4 addr show >&2 || true
          exit 2
        fi

        # ip_forward is configured via docker-compose `sysctls:` above.
        # Some Docker setups mount /proc/sys read-only inside the container, so don't write here.
        if [ "$(cat /proc/sys/net/ipv4/ip_forward 2>/dev/null || echo 0)" != "1" ]; then
          echo "net.ipv4.ip_forward is not enabled (expected 1). Check docker-compose sysctls/daemon settings." >&2
          exit 2
        fi

        # NAT (masquerade) A -> B
        iptables -t nat -A POSTROUTING -o "$$external_if" -j MASQUERADE

        # Forwarding rules
        iptables -A FORWARD -i "$$internal_if" -o "$$external_if" -j ACCEPT
        iptables -A FORWARD -i "$$external_if" -o "$$internal_if" -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT

        tail -f /dev/null

  nat2:
    image: alpine:3.23
    container_name: nat2
    cap_add:
      - NET_ADMIN
      - NET_RAW
    sysctls:
      net.ipv4.ip_forward: "1"
    environment:
      INTERNAL_IP: 192.168.0.2   # netC side
      EXTERNAL_IP: 10.0.0.3   # netB side
    networks:
      netC:
        ipv4_address: 192.168.0.2
      netB:
        ipv4_address: 10.0.0.3
    command:
      - sh
      - -euxc
      - |
        apk add --no-cache iptables iproute2

        : "$${INTERNAL_IP:?INTERNAL_IP is required}"
        : "$${EXTERNAL_IP:?EXTERNAL_IP is required}"

        internal_if="$(ip -o -4 addr show | awk -v ip="$${INTERNAL_IP}" '$4 ~ ip"/" {print $2; exit}')"
        external_if="$(ip -o -4 addr show | awk -v ip="$${EXTERNAL_IP}" '$4 ~ ip"/" {print $2; exit}')"

        if [ -z "$$internal_if" ] || [ -z "$$external_if" ]; then
          echo "Failed to detect NAT interfaces (internal_if=$$internal_if external_if=$$external_if)" >&2
          echo "ip -o -4 addr show output:" >&2
          ip -o -4 addr show >&2 || true
          exit 2
        fi

        # ip_forward is configured via docker-compose `sysctls:` above.
        # Some Docker setups mount /proc/sys read-only inside the container, so don't write here.
        if [ "$(cat /proc/sys/net/ipv4/ip_forward 2>/dev/null || echo 0)" != "1" ]; then
          echo "net.ipv4.ip_forward is not enabled (expected 1). Check docker-compose sysctls/daemon settings." >&2
          exit 2
        fi

        # NAT (masquerade) A -> B
        iptables -t nat -A POSTROUTING -o "$$external_if" -j MASQUERADE

        # Forwarding rules
        iptables -A FORWARD -i "$$internal_if" -o "$$external_if" -j ACCEPT
        iptables -A FORWARD -i "$$external_if" -o "$$internal_if" -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT

        tail -f /dev/null

  relay:
    build:
      context: ../../
      dockerfile: examples/cpp/Dockerfile
    image: relay
    container_name: relay
    command: ["/app/ping", "--role", "relay", "--force-hop", "--listen", "/ip4/0.0.0.0/tcp/41000", "--seed-phrase", "relay-one"]
    tty: true
    stdin_open: true
    networks:
      netB:
        ipv4_address: 10.0.0.10
    ports:
      - "41000:41000"

  client_a:
    build:
      context: ../../
      dockerfile: examples/cpp/Dockerfile
    image: client
    container_name: client_a
    cap_add:
      - NET_ADMIN
    depends_on:
      - nat1
      - relay
    networks:
      netA:
        ipv4_address: 172.20.0.10
    command: ["/app/ping", "--listen", "/ip4/0.0.0.0/tcp/41001", "--bootstrap", "/ip4/10.0.0.10/tcp/41000/p2p/12D3KooWSNqRTV2JccvWYTxtDtXUk9Y1m7EcGLy65eRN1qSrDkdp", "--seed-phrase", "peer-a", "--target", "/ip4/192.168.0.10/tcp/41000/p2p/12D3KooWD5NqycxsN1Dx8P7nZcH8SdhT1TC38iHiMbRd599qpzr7"]
    tty: true
    stdin_open: true

  client_b:
    build:
      context: ../../
      dockerfile: examples/cpp/Dockerfile
    image: client
    container_name: client_b
    cap_add:
      - NET_ADMIN
    depends_on:
      - nat2
      - relay
    networks:
      netC:
        ipv4_address: 192.168.0.10
    command: ["/app/ping", "--listen", "/ip4/0.0.0.0/tcp/41001", "--bootstrap", "/ip4/10.0.0.10/tcp/41000/p2p/12D3KooWSNqRTV2JccvWYTxtDtXUk9Y1m7EcGLy65eRN1qSrDkdp", "--seed-phrase", "peer-b", "--target", "/ip4/172.20.0.10/tcp/41000/p2p/12D3KooWKDAxUshAR3XqKiy9pgo1PCrSMHWvNfAopdTthBApdgDG"]
    tty: true
    stdin_open: true

networks:
  netA:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/24
  netB:
    driver: bridge
    ipam:
      config:
        - subnet: 10.0.0.0/24
  netC:
    driver: bridge
    ipam:
      config:
        - subnet: 192.168.0.0/24
